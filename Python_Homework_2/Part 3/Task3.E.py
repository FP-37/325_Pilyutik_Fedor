"""
Игрушечный лабиринт представляет собой прозрачную плоскую прямоугольную коробку,
внутри которой есть препятствия и перемещается шарик. Лабиринт можно наклонять влево, вправо,
к себе или от себя, после каждого наклона шарик перемещается в заданном направлении до ближайшего препятствия
или до стенки лабиринта, после чего останавливается. Целью игры является загнать шарик в одно из специальных
отверстий – выходов. Шарик проваливается в отверстие, если оно встречается на его пути
(шарик не обязан останавливаться в отверстии).

Первоначально шарик находится в левом верхнем углу лабиринта. Гарантируется, что решение существует и левый верхний угол
не занят препятствием или отверстием.

Входные данные
В первой строке входного файла записаны числа N и M – размеры лабиринта (целые положительные числа, не превышающие 100).
Затем идет N строк по M чисел в каждой – описание лабиринта. Число 0 в описании означает свободное место,
число 1 – препятствие, число 2 – отверстие.

Выходные данные
Выведите единственное число – минимальное количество наклонов, которые необходимо сделать,
чтобы шарик покинул лабиринт через одно из отверстий.
"""
from collections import deque
import sys

DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def read_input():
    n, m = map(int, sys.stdin.readline().split())
    grid = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]
    return n, m, grid

def move_ball(x, y, dx, dy, grid):
    while 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]) and grid[x + dx][y + dy] != 1:
        x += dx
        y += dy
        if grid[x][y] == 2:
            return x, y, True
    return x, y, False

def bfs(n, m, grid):
    queue = deque([(0, 0, 0)])
    visited = set([(0, 0)])

    while queue:
        x, y, moves = queue.popleft()

        for dx, dy in DIRECTIONS:
            new_x, new_y, is_hole = move_ball(x, y, dx, dy, grid)

            if is_hole:
                return moves + 1

            if (new_x, new_y) not in visited:
                visited.add((new_x, new_y))
                queue.append((new_x, new_y, moves + 1))

    return -1

if __name__ == "__main__":
    n, m, grid = read_input()
    print(bfs(n, m, grid))