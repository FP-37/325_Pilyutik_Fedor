"""
Максимальное время работы на одном тесте:	1 секунда
На шахматной доске NxN в клетке (x1, y1) стоит голодный шахматный конь. Он хочет попасть в клетку (x2, y2),
где растет вкусная шахматная трава. Какое наименьшее количество ходов он должен для этого сделать?

Входные данные
На вход программы поступает  пять чисел: N, x1, y1, x2, y2 (5 <= N <= 20, 1 <= x1, y1, x2, y2 <= N).
Левая верхняя клетка доски имеет координаты (1, 1), правая нижняя - (N, N).

Выходные данные
В первой строке выведите единственное число K - наименьшее необходимое число ходов коня. В каждой из следующих
K+1 строк должно быть записано 2 числа - координаты очередной клетки в пути коня.

Пример выходного файла ниже неполный, правильный пример такой:

4
3 3
2 1
1 3
3 2
5 1
"""
from collections import deque

def bfs(N, x1, y1, x2, y2):
    moves = [(-2, -1), (-1, -2), (1, -2), (2, -1),
             (2, 1), (1, 2), (-1, 2), (-2, 1)]

    queue = deque([(x1, y1)])
    parent = { (x1, y1): None }

    while queue:
        x, y = queue.popleft()

        if (x, y) == (x2, y2):
            path = []
            while (x, y) != (x1, y1):
                path.append((x, y))
                x, y = parent[(x, y)]
            path.append((x1, y1))
            path.reverse()
            return path

        for dx, dy in moves:
            nx, ny = x + dx, y + dy
            if 1 <= nx <= N and 1 <= ny <= N and (nx, ny) not in parent:
                parent[(nx, ny)] = (x, y)
                queue.append((nx, ny))

N = int(input())
x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())

path = bfs(N, x1, y1, x2, y2)

print(len(path) - 1)
for p in path:
    print(*p)